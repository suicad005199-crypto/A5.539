function generateOptimizedPrediction() {
  if (data.length === 0) {
    alert("請先載入歷史資料 CSV");
    return;
  }

  const totalDraws = data.length;
  const freq = {}, lastOccur = {};

  // 計算每個號碼出現頻率與最後出現期數
  data.forEach((draw, idx) => {
    draw.forEach(n => {
      freq[n] = (freq[n] || 0) + 1;
      lastOccur[n] = idx;
    });
  });

  // 計算每個號碼的綜合分數
  const scores = [];
  for (let n = 1; n <= 39; n++) {
    const f = (freq[n] || 0) / totalDraws;
    const m = totalDraws - (lastOccur[n] || 0);
    let score = 0;
    if (f < 0.08) score += 25;   // 冷號補分
    if (f > 0.12) score += 5;    // 熱號加分
    score += m * 0.5;            // 遺漏期數加分
    if (n % 2 === 0) score += 1; // 偏奇偶加分
    scores.push({ n, score });
  }

  let bestCombo = [];
  let highestHitRate = -1;

  // 模擬多組候選組合
  for (let iter = 0; iter < 10000; iter++) {
    const pool = scores.sort((a, b) => b.score - a.score).slice(0, 15);
    const selected = [];
    while (selected.length < 5) {
      const pick = pool[Math.floor(Math.random() * pool.length)].n;
      if (!selected.includes(pick)) selected.push(pick);
    }
    selected.sort((a, b) => a - b);

    // 計算模擬 ≥3 顆命中率
    let hit3 = 0;
    data.forEach(draw => {
      const match = draw.filter(n => selected.includes(n)).length;
      if (match >= 3) hit3++;
    });
    const hitRate = (hit3 / totalDraws) * 100;

    if (hitRate > highestHitRate) {
      highestHitRate = hitRate;
      bestCombo = selected;
    }
  }

  // 顯示結果（只顯示 ≥3 顆命中率最高的組合）
  const resultDiv = document.getElementById("panelC");
  resultDiv.style.display = "block";
  resultDiv.innerHTML = `
    <div class="numbers-grid">
      ${bestCombo.map(n => `<div class="number-ball hot">${n}</div>`).join('')}
    </div>
    <div class="status success">
      <p>模擬歷史回測 ≥3 顆命中率：${highestHitRate.toFixed(1)}%</p>
    </div>
  `;
}
