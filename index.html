// 生成預測號碼（優化版：歷史頻率加權 + 簡單約束）
function generatePredictionNumbers(stats) {
  const { frequency, sumStats, avgOdd, totalDraws } = stats;

  // 1. 計算每個號碼的權重（歷史出現次數）
  const weights = new Array(40).fill(0); // index 1~39
  let totalWeight = 0;

  for (let num = 1; num <= 39; num++) {
    const count = frequency[num] || 0;
    weights[num] = count > 0 ? count : 0.1; // 避免完全沒出現的號碼機率為0
    totalWeight += weights[num];
  }

  // 2. 加權隨機抽樣函數
  function weightedRandom() {
    let r = Math.random() * totalWeight;
    for (let num = 1; num <= 39; num++) {
      r -= weights[num];
      if (r <= 0) return num;
    }
    return 39; // 保險
  }

  // 3. 產生候選組合，直到滿足約束
  const MAX_TRIES = 500;
  let best = null;
  let bestDiff = Infinity;

  for (let tryCount = 0; tryCount < MAX_TRIES; tryCount++) {
    const selected = new Set();
    let oddCount = 0;

    // 抽5個不重複號碼
    while (selected.size < 5) {
      const num = weightedRandom();
      if (!selected.has(num)) {
        selected.add(num);
        if (num % 2 === 1) oddCount++;
      }
    }

    const nums = [...selected].sort((a, b) => a - b);
    const sum = nums.reduce((a, b) => a + b, 0);
    const span = nums[4] - nums[0];

    // 約束條件（可調整寬鬆度）
    const sumDiff = Math.abs(sum - sumStats.avg);
    const oddDiff = Math.abs(oddCount - avgOdd);
    const currentDiff = sumDiff * 0.7 + oddDiff * 20 + (span < 15 ? 40 : 0);

    // 記錄目前最好的
    if (currentDiff < bestDiff) {
      bestDiff = currentDiff;
      best = nums;
    }

    // 早點滿足就離開（可選）
    if (sumDiff <= 20 && oddDiff <= 1 && span >= 15) {
      return nums;
    }
  }

  // 如果都找不到完美解，回傳最接近的
  return best || Array.from({ length: 5 }, () => weightedRandom()).sort((a, b) => a - b);
}
